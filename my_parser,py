import ply.yacc as yacc
from lexer import tokens
from symbol_table import SymbolTable
from tac import TAC

# Initialize global objects
symbol_table = SymbolTable()
tac = TAC()

# Operator precedence
precedence = (
    ('left', 'PLUS', 'MINUS'),
    ('left', 'TIMES', 'DIVIDE'),
    ('right', 'EQ'),
)

def p_program(p):
    '''program : statement_list'''
    print("[Syntax Analysis] Parsed program")
    p[0] = p[1]

def p_statement_list(p):
    '''statement_list : statement statement_list
                      | empty'''
    print("[Syntax Analysis] Parsed statement list")
    p[0] = p[1] if len(p) == 2 else p[1] + (p[2] if p[2] else [])

def p_statement(p):
    '''statement : declaration
                 | assignment
                 | if_stmt
                 | while_stmt'''
    print(f"[Syntax Analysis] Parsed statement: {p[1]['type']}")
    p[0] = [p[1]]

def p_declaration(p):
    '''declaration : INT ID EQ NUMBER SEMI'''
    symbol_table.add(p[2], 'int', symbol_table.scope)
    tac.emit("=", p[4], None, p[2])
    print(f"[Syntax Analysis] Parsed declaration: int {p[2]} = {p[4]}")
    p[0] = {"type": "decl", "id": p[2], "value": p[4]}

def p_assignment(p):
    '''assignment : ID EQ expression SEMI'''
    symbol_table.lookup(p[1], symbol_table.scope)
    tac.emit("=", p[3]["place"], None, p[1])
    print(f"[Syntax Analysis] Parsed assignment: {p[1]} = {p[3]['place']}")
    p[0] = {"type": "assign", "id": p[1], "value": p[3]}

def p_if_stmt(p):
    '''if_stmt : IF LPAREN expression RPAREN LBRACE statement_list RBRACE'''
    label_true = tac.new_label()
    label_end = tac.new_label()
    tac.emit("if", f"{p[3]['place']} != 0", None, label_true)
    tac.emit("goto", label_end, None, None)
    tac.emit("label", label_true, None, None)
    symbol_table.enter_scope()
    for stmt in p[6]:
        pass  # Processed in TAC
    symbol_table.exit_scope()
    tac.emit("label", label_end, None, None)
    print(f"[Syntax Analysis] Parsed if statement with condition {p[3]['place']}")
    p[0] = {"type": "if", "condition": p[3], "statements": p[6]}

def p_while_stmt(p):
    '''while_stmt : WHILE LPAREN expression RPAREN LBRACE statement_list RBRACE'''
    label_start = tac.new_label()
    label_true = tac.new_label()
    label_end = tac.new_label()
    tac.emit("label", label_start, None, None)
    tac.emit("if", f"{p[3]['place']} != 0", None, label_true)
    tac.emit("goto", label_end, None, None)
    tac.emit("label", label_true, None, None)
    symbol_table.enter_scope()
    for stmt in p[6]:
        pass  # Processed in TAC
    symbol_table.exit_scope()
    tac.emit("goto", label_start, None, None)
    tac.emit("label", label_end, None, None)
    print(f"[Syntax Analysis] Parsed while statement with condition {p[3]['place']}")
    p[0] = {"type": "while", "condition": p[3], "statements": p[6]}

def p_expression(p):
    '''expression : expression PLUS expression
                  | expression MINUS expression
                  | expression TIMES expression
                  | expression DIVIDE expression
                  | expression LT expression
                  | expression GT expression
                  | NUMBER
                  | ID'''
    if len(p) == 4:
        temp = tac.new_temp()
        tac.emit(p[2], p[1]["place"], p[3]["place"], temp)
        print(f"[Syntax Analysis] Parsed expression: {p[1]['place']} {p[2]} {p[3]['place']}")
        p[0] = {"place": temp, "type": "int"}
    else:
        if isinstance(p[1], str):  # ID case
            symbol_table.lookup(p[1], symbol_table.scope)
            print(f"[Syntax Analysis] Parsed expression: ID {p[1]}")
            p[0] = {"place": p[1], "type": "int"}
        else:  # NUMBER case
            print(f"[Syntax Analysis] Parsed expression: NUMBER {p[1]}")
            p[0] = {"place": p[1], "type": "int"}

def p_empty(p):
    '''empty :'''
    print("[Syntax Analysis] Parsed empty statement")
    p[0] = []

def p_error(p):
    """Handle syntax errors."""
    if p:
        print(f"[Syntax Analysis] Syntax error at '{p.value}'")
    else:
        print("[Syntax Analysis] Syntax error at EOF")

# Create parser
parser = yacc.yacc()

def parse(code):
    """Parse the input code and return AST, symbol table, and TAC."""
    global symbol_table, tac
    symbol_table = SymbolTable()
    tac = TAC()
    ast = parser.parse(code)
    return ast, symbol_table.get_symbols(), tac.to_string()
